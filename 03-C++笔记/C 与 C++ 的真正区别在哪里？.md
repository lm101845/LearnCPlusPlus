# C 与 C++ 的真正区别在哪里？

> https://www.zhihu.com/question/28834538/answer/1654211948

C是中餐厨师的菜刀，做啥菜就那一把刀，切菜切肉切鱼，都是这一把刀，刀工好的师傅，豆腐都能切成一朵花。无论你提什么概念，都能用指针给你做出来，如果不行，那就用指向函数的指针，指针的指针，指向[函数指针](https://www.zhihu.com/search?q=%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A%221654211948%22%7D)的指针。。。。



C++就是西餐厨师的刀，有一大堆不同款式的刀，切不同的东西得用不同的刀，每种刀还有不同的手法，显得非常专业，高大上。



[中厨刀](https://www.zhihu.com/search?q=%E4%B8%AD%E5%8E%A8%E5%88%80&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A%221654211948%22%7D)，简单，但深入高阶难，难在复杂使用技巧，做啥都是这一把刀，要切出花来，刀工需要练的，一般人练不好。

西厨刀，复杂，但是使用难度相对低，需要掌握一堆刀的功能限制。但刀太多，功能干涉太多，没准啥时候没吃透就踩坑了。真正吃透也很难。



西餐厨师离开这些功能复杂的西厨刀，就会显得手忙脚乱，如果只有一把中厨刀，甚至不会做菜了。

中餐厨师用这堆西厨刀，会不耐烦，最后还是挑出一把最顺手的，当成中厨刀用，其他的闲置。



西餐厨师经常炫技方式就是这刀我会用，那刀我也会用，组合起来还会用。一大堆使用西厨刀的术语名词和隐藏小技巧。

中餐厨师炫技方式就是，随便你提啥需求，我都是用这一把刀给你切出来，刀工还强。



西餐厨师看不起中餐厨师，就一把刀，太简陋，没逼格。

中餐厨师看不起西餐厨师，一大堆刀，也没见菜更好吃，而且那一堆西厨刀的功能，咱就一把中厨刀也能切出来。

是的，C++所有新特性，用C都能做出来，无论是面向对象还是[函数式编程](https://www.zhihu.com/search?q=%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A%221654211948%22%7D)还是元编程。所以，不要再说C++是面向对象的，而C是面向过程的，这不是本质区别。但C[脑补编译器](https://www.zhihu.com/search?q=%E8%84%91%E8%A1%A5%E7%BC%96%E8%AF%91%E5%99%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A%221654211948%22%7D)确实也不是轻松的活。



初级阶段，C比C++容易学，毕竟语法简单，关键词少。

中级阶段，C++更容易更强大。毕竟有强大的编译器支持，只要掌握这些语言特性，就已能实现强大的高级功能。而C还需要脑补编译器，才能实现面向对象等高级特性，不是每个人都能做到，大学课程也不教这些。

高级阶段，C++可能变成语言发烧友，各种特性组合会成为泥潭，牵扯极大的精力。而用C度过中阶段后，更深入理解计算机和程序的哲学本质后，会有一种无所不能的感觉。C反而是束缚更少，更自由，更高效的工具。



一个C++高手，能准确掌握更多更复杂的高级语言特性组合，高效率响应业务需求，快速迭代，代码优雅简洁，鲁棒性好，维护性好，扩展性好。

一个C高手，能掌握更多的基础模块实现方案，什么[无锁消息队列](https://www.zhihu.com/search?q=%E6%97%A0%E9%94%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A%221654211948%22%7D)，内存管理，线程调度器，时钟，各种算法库，甚至不同风格的面向对象的架构，这都是自己纯手工打造，然后根据业务需要定制这些基础模块的设计方案和参数，以追求应用业务的极致性能，和极致可靠。



C高手往往不太喜欢C++那一套，因为很多东西不能自己掌控。这让习惯掌控一切的C程序员觉得脚下有些发虚。

C++高手往往也不太喜欢C，因为很多轮子要自己造。让习惯快速响应迭代的C++程序员无比烦躁。



都是[图灵完备](https://www.zhihu.com/search?q=%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A%221654211948%22%7D)的语言。C能做到的，C++肯定能做，毕竟C++是C超集。而C++能做到的，其实C也能做到，只需要脑补一种编译范式而已。

如果非要在哲学上说C和C++有什么区别，那么C是心法派，C++是语法派。

每当有新概念新范式出现，C++标准组织就会开发新特性新语法，以提供这种新范式。

而C则脑补一种新的心法（数据结构和算法）来解决，在语法层面尽量少增加特性，几乎很少变化。



C和C++又有点像武侠之气宗和剑宗

入门是气宗C简单，入门要学的东西少。而剑宗C++不仅要学气宗的C，还需要学剑宗的这些++，入门就复杂一些。

修炼进展，是剑宗C++来的快，毕竟有一大堆现成的语法范式，不需要知其所以然，只需会用，就能发挥剑宗招式的威力。而气宗C还要掌握一大堆基础数据结构和算法以及[设计范式](https://www.zhihu.com/search?q=%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A%221654211948%22%7D)，研究精深，知其所以然，才能真正发挥威力。

上限，是气宗C来的高。等真正深入到高阶编程，会发现每一种现成的语法范式和库，某种意义上，便捷的另一面就是束缚。语言编译器做的工作越多，库越强大，编程束缚反而越大；而语法越少编译器越简单，反而自由度越高而且越稳定可靠，可供发挥的上限也越高。

对于以C为主的高水平团队，C现有的语法不是太少，而是多了，反而还要设定一些编程规范加以限制。所以一些真正经典优美的C代码，往往都是朴实无华的，很少在语句技巧层面炫技。

以C++为主的高水平团队，也常常制定编程规范，对语法使用加以限制，限制可能比C更多。

一个团队水平高低，从其编程规范就可见一斑。水平越高，往往规矩越多。

当然，真正的高手，都是气剑双修的，在语法层面几乎都是朴实无华，从不炫技，人家炫的是思想。



------



有人想听Python是什么刀。

嗯，窃以为，Python更多像速冻食品。

速冻食品能快速的满足需求填饱肚子，而不是饿着肚子还需要洗切烹饪，在底层原料处理环节消耗大量的时间精力。

Python最大优势就是用起来方便。不是每个人都需要懂编译器实现，各种算法的细节，各种指针的奇技淫巧。大部分人需要的只是快速方便的解决现实问题。

所以，与其说Python兼容面向对象和[面向过程](https://www.zhihu.com/search?q=%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A%221654211948%22%7D)，不如说Python是面向问题的。

Python的编译器，和大量的库，都是用C/C++写的，会熟练使用这些库，也就站在了巨人的肩膀上，还不是一个，是一群巨人。掌握这些，足以快速的解决多数问题。

那么速冻食品就没有逼格，手工现做就有逼格？其实也不是，一切从现实需求出发，能最快最好满足需求的工具，就是最好的工具。

Python高手，会掌握大量的库和设计范式，信手拈来，快速满足需求。

而进阶Python高手，还会自己用C来做库，以在某些特殊场景下，突破开源库的功能和规格束缚。



------



又有朋友问，JAVA，C#，VB，VBA是什么刀？

这真当咱是刀匠吗？还是铁匠？ 嗯 ？ ~ o(*￣▽￣*)o

好吧，所有的刀款式，这回一次性解决。





所有编程语言，本质上都是工具。

所有刀，本质上也是工具。

都是工具，工具间，自然有类似特征，会有些相通之处。

理解这些有趣的相通之处，有利于我们快速的掌握一种新工具。而不是迷失在新工具的细节之中。



而这些有趣的相通之处，其实并不是孤立零散的。

掌握这些有趣相通之处的分布规律，可以更深刻的理解这些相通之处。

然后，对新工具理解，就是二次方的深刻度。



就像练武，学会心法，招式训练效果倍增。

而学会心法的心法，功力提升速度则加速到二次方。



二次方程，需要一个坐标轴。

建立坐标轴，首先需要一个零点，然后需要一个无穷远。

从零点到无穷远，就是一个数轴。



当你内心建立起这样一个数轴，所谓心法的心法，就水落石出，一目了然，不需要别人告诉你特征，打比方解释给你听，扯什么[中式菜刀](https://www.zhihu.com/search?q=%E4%B8%AD%E5%BC%8F%E8%8F%9C%E5%88%80&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A%221654211948%22%7D)和西式厨刀的故事。

你自己就可以发现规律。

你自己就可以打无数的比方，信手拈来。



那么，编程语言的零点，在哪里？

[图灵机](https://www.zhihu.com/search?q=%E5%9B%BE%E7%81%B5%E6%9C%BA&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A%221654211948%22%7D)。

是的，图灵机，是近几十年来一切计算机技术的起点。



那么，无穷远，又在哪里？

宇宙间万事万物的无限复杂度，不正是无穷远吗？



当我们从图灵机出发，去解决宇宙间万事万物的无限复杂的过程，就是从零点到无穷远的过程，就产生了数轴。

一旦有了数轴，所有的芯片架构和编程语言，都可以在这数轴上有一个位置，也就是坐标。

当你俯瞰这些坐标构成的散点图，哦，原来如此，不过如此，就像魔术师的技巧被解密了。



让我们出发。

图灵机是零点，第一个点在哪里?

[冯诺依曼架构](https://www.zhihu.com/search?q=%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%9E%B6%E6%9E%84&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A%221654211948%22%7D)。



图灵机是数学理论上的抽象模型，而冯诺依曼架构个是可落地的工程计算架构。

实现冯诺依曼架构，需要一套指令集、一些指令集配套的寄存器、运算单元、地址总线、数据总线、内存等。然后，就可以开始机器码的编程。

基于CPU指令集的[机器码编程](https://www.zhihu.com/search?q=%E6%9C%BA%E5%99%A8%E7%A0%81%E7%BC%96%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A%221654211948%22%7D)，可比基于图灵机的机器码编程来的高效的多。



但，每一步效率的提升，都是拿自由兑换的。

指令集也不例外，有位宽的限制，有指令位宽的区别，有寄存器的区别，有精简指令集[复杂指令集](https://www.zhihu.com/search?q=%E5%A4%8D%E6%9D%82%E6%8C%87%E4%BB%A4%E9%9B%86&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A%221654211948%22%7D)区别，等等，等等。

指令集，正是编程遇到的第一次束缚。



所以，从冯诺依曼架构开始出发，有各种各样的指令集。试图用不同的实现折中，来换取不同的效率优化。



机器码编程太累，就有了汇编。汇编跟机器码几乎是一一映射，无损压缩。



汇编还是累，就有了一些初步的高级语言，如广泛应用成熟的C。

C提供了函数，方便了程序设计，但却剥夺了CPU寄存器的可见性，戴上了栈空间的束缚，等等。

C++提供了面向对象的语法便捷，但面向对象却限制了指令交叉访问数据的自由和效率。

Java等语言提供了内存管理便捷，但剥夺了程序自主内存管理的自由和效率。



面向宇宙万物的无限复杂度，每一步编程效率的提升，都是拿自由兑换的，毫无例外。

当我们想要更大的便捷性和功能，就面向具体问题，以可以忍受的些许自由代价，来换取解决具体问题的范式，以此获得效率的提升，也就是更高级的语言。

当我们想要更大的自由度，就向零点回退。

踩着前人的脚步，熟悉每一步自由换取便捷的手法，你心中就有了数轴。

有了数轴，你就可以俯瞰所有的语言、程序、和架构设计。

熟悉这一切，你甚至可以根据需要创造新的编程语言，新的设计范式。

就是这样而已，没什么魔法。

本文完。

课后作业：

图灵机真的是零点吗？

这个轴的负数方向意味着什么？