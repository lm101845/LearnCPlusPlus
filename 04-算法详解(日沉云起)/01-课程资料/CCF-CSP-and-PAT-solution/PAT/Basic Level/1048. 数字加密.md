# 【PAT B-1048】数字加密

## 题意概述

本题要求实现一种数字加密方法。首先固定一个加密用正整数 A，对任一正整数 B，将其每 1 位数字与 A 的对应位置上的数字进行以下运算：对奇数位，对应位的数字相加后对 13 取余——这里用 J 代表 10、Q 代表 11、K 代表 12；对偶数位，用 B 的数字减去 A 的数字，若结果为负数，则再加 10。这里令个位为第 1 位。

## 输入输出格式

输入在一行中依次给出 A 和 B，其间以空格分隔。

在一行中输出加密后的结果。

## 数据规模

A 和 B 均为不超过 100 位的正整数。

## 算法设计

首先要理解，第 1 位是字符串的末位，从右向左位数逐渐递增。用字符串读入两个整数 A 和 B，并通过字符串 C 来记录最后输出结果。如果直接遍历就需要定义两个索引分别从 A 字符串和 B 字符串的末位开始向前遍历，为了编码方便，不妨先将 A，B 字符串进行翻转。这样就可以只定义一个索引从开始位遍历即可。遍历过程中按要求操作，并将结果记录在 C 字符串中，最后将 C 字符串输出即可。

## 注意点

1. 字符串下标从 0 开始，而题目中个位从 1 开始编号，所以对于奇数位偶数位的处理要反过来。
2. 字符串 A 和字符串 B 的长度不定，可能 A 比 B 长，可能 B 比 A 长，可能 A、B 一样长，这点要特别注意。

## C++代码

```cpp
#include <bits/stdc++.h>
using namespace std;
using gg = long long;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    string ai, bi, c, h = "0123456789JQK";
    cin >> ai >> bi;
    reverse(ai.begin(), ai.end());
    reverse(bi.begin(), bi.end());
    for (int i = 0; i < ai.size() or i < bi.size(); ++i) {
        int k1 = i < ai.size() ? ai[i] - '0' : 0,
            k2 = i < bi.size() ? bi[i] - '0' : 0;
        c.push_back(i % 2 == 0 ? h[(k1 + k2) % 13] : (10 + k2 - k1) % 10 + '0');
    }
    reverse(c.begin(), c.end());
    cout << c;
    return 0;
}
```
