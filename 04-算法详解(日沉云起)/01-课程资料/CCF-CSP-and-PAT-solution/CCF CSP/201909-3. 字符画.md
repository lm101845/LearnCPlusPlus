# 【CCF CSP-20190903】字符画

## 算法设计

首先说明一下本题需要用到的 10 进制与 16 进制的转换方法：

1. `cout << hex << uppercase << setfill('0')`：输出时会自动输出成 16 进制数，其中 10~15 用大写字母`A~F`表示，输出的 16 进制数不足位数要求的在高位补 0
2. `stoll(s, 0, 16)`：将 16 进制字符串 s 转换成 10 进制数并返回

我们可以利用`array<int,3>`来存储一个 RGB 值，`0~2`索引位置的元素分别存储 R、G、B 颜色分量的值。我们利用一个二维数组`image`来存储整个图像的像素点的 RGB 值。对于读取到的每一行 RGB 字符串，如果该字符串只有 2 个字符（例如`#a`），则在其末尾添加 5 个原字符串的末尾字符，扩充成 6 位；如果有 4 个字符（例如`#abc`），则将其`1~3`索引位置的字符各变成 2 位，转换代码为`rgb = "#" + string(2, rgb[1]) + string(2, rgb[2]) + string(2, rgb[3])`。对于 7 位的 RGB 字符串，利用字符串的`substr`函数进行分割，并利用`stoll`函数将其转换成 10 进制数，存储在一个`array<int,3>`变量中。

然后我们定义 RGB 值`start`和`last`，分别存储默认状态下的背景色和上一个块的背景色，均初始化为`{0,0,0}`。遍历整个图像`image`，针对每一块，得出 RGB 的平均值，如果当前块的背景色和`last`以及`start`均不同，按 16 进制数输出所有更改背景色代码的字符；如果当前块的背景色和`start`相同，按 16 进制数输出所有重置默认状态代码的字符；如果当前块的背景色和`last`相同，什么也不做。然后在每一个块后按 16 进制数输出一个空格。在输出每一行后，查看这一行最后一个块和`start`是否相同，如果不同需要重置成默认状态，需要按 16 进制数输出所有重置默认状态代码的字符，然后置`last`为默认状态，按十六进制数输出一个换行符即可。

## 注意点

本题要注意的地方极多，稍不留神，可能花很长时间写的代码提交之后只有 0 分……所以要格外留意。

1. 本题只涉及到了更改背景色，并没有涉及到前景色的更改。
2. 对于每一个命令行中的字符，均需按 16 进制数输出其 ASCII 码，且输出的 16 进制数要有 2 位，不足两位在高位补 0。
3. RGB 颜色分量值在 0~255 之间，不能用 char 存储（char 存储范围是`-128~127`），最好用 int 存储。
4. 对于命令行中的 RGB 值，要先将 10 进制的 RGB 值转换成字符串，再按 16 进制数形式逐个字符地输出。例如一个 RGB 的一个颜色分量值为 128，需要按 16 进制数的形式分别输出`1`、`2`、`8`这 3 个字符，而不是直接按 16 进制数形式输出 128 这个 10 进制数。
5. 计算 RGB 颜色分量平均值要向 0 取整，所以直接使用 C++中的除法运算就可以了。
6. 输出每一个块之后都要按 16 进制数形式输出一个空格，输出每一行字符串后都要按 16 进制数形式输出一个换行符。
7. 输出每一行字符之后，输出换行符之前，要检查当前 RGB 值是否是默认状态，如果不是，要置为默认状态，**且要更新代码中的上一个状态为默认状态**。
8. 如果某个状态的 RGB 值与其前一个状态相同，那么什么也不要做，直接输出一个空格即可。
9. 如果一个状态的 RGB 值刚好与默认状态完全相同，要使用重置转义序列。
10. 先检查一个状态是否与上一个状态相同，再检查是否与默认状态相同。也就是说，假如上一个状态就是默认状态，当前状态也是默认状态，那么无需输出重置转义序列，直接输出一个空格即可。

## C++代码

```cpp
#include <bits/stdc++.h>
using namespace std;
using gg = long long;
using ag = array<gg, 3>;
void output(string& s, ag rgb = {0, 0, 0}) {  //输出
    for (char c : s)
        if (c == 'R' or c == 'G' or c == 'B') {  //是RGB数值
            string t = to_string(rgb[c == 'R' ? 0 : c == 'G' ? 1 : 2]);  //将数值转换成字符串
            for (gg cc : t)  //遍历字符串
                cout << "\\x" << setw(2) << cc;  //输出16进制数
        } else
            cout << "\\x" << setw(2) << gg(c);  //输出16进制数
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    string back = "\x1b[48;2;R;G;Bm", reset = "\x1b[0m";  //背景色和重置默认值字符串
    gg m, n, p, q;
    cin >> m >> n >> p >> q;
    vector<vector<ag>> image(n);  //图像像素
    string rgb;
    for (gg i = 0; i < n; ++i) {
        for (gg j = 0; j < m; ++j) {
            cin >> rgb;
            if (rgb.size() == 2)  //只有2位字符
                rgb += string(5, rgb.back());  //字符串末尾添加5个末尾字符
            else if (rgb.size() == 4)  //只有4位字符
                rgb = "#" + string(2, rgb[1]) + string(2, rgb[2]) + string(2, rgb[3]);  //添加成为6位
            image[i].push_back({0, 0, 0});
            for (gg t = 0; t < 3; ++t)  //计算RGB数值，将16进制数转换成10进制
                image[i].back()[t] = stoll(rgb.substr(2 * t + 1, 2), 0, 16);
        }
    }
    cout << hex << uppercase << setfill('0');
    ag last = {0, 0, 0}, start = {0, 0, 0};
    for (gg i = 0; i < n / q; ++i) {  //遍历所有像素
        for (gg j = 0; j < m / p; ++j) {
            ag cur = {0, 0, 0};
            for (gg r = 0; r < q; ++r) {  //计算块内RGB颜色分量之和
                for (gg s = 0; s < p; ++s) {
                    for (gg t = 0; t < 3; ++t)
                        cur[t] += image[i * q + r][j * p + s][t];
                }
            }
            for (gg t = 0; t < 3; ++t)  //计算RGB颜色分量平均值
                cur[t] /= p * q;
            if (cur != last)  //和上一个块颜色分量不同
                if (cur == start)  //和默认颜色分量一致，输出重置转义序列
                    output(reset);
                else
                    output(back, cur);
            last = cur;  //更新上一个状态为当前状态
            cout << "\\x" << setw(2) << gg(' ');  //每一个块后输出一个空格
        }
        if (last != start)  //每一行结束后恢复默认状态
            output(reset);
        last = start;  //每一行结束后更新上一个状态位默认状态
        cout << "\\x" << setw(2) << gg('\n');  //每一行字符后输出一个换行
    }
    return 0;
}
```
