# 【CCF CSP-20200901】称检测点查询

## 题意概述

某市设有 n 个核酸检测点，编号从 1 到 n，其中 i 号检测点的位置可以表示为一个平面整数坐标$(x_i,y_i$。为方便预约核酸检测，请根据市民所在位置$(X,Y)$，查询距其最近的三个检测点。多个检测点距离相同时，编号较小的视为更近。市民到第$i$号检测点的距离公式为$D_i=(X-x_i)^2+(Y-y_i)^2$。

## 输入输出格式

输入第一行包含用空格分隔的三个整数 n，X 和 Y，表示检测点总数和市民所在位置。第二行到第 n+1 行依次输入 n 个检测点的坐标。第$i+1$行（$1<=i<=n$）包含用空格分隔的两个整数$x_i$和$y_i$，表示$i$号检测点所在位置。

输出共三行，按距离从近到远，依次输出距离该市民最近的三个检测点编号。

## 数据规模

$$3<=n<=200$$

## 算法设计

可以维护一个大小为 3 的红黑树（当然用堆也可以），每次比较当前检测点到市民的距离与红黑树中的最大距离，如果当前检测点到市民的距离更小，则从红黑树中删除最大距离，将当前检测点放入红黑树中。最后输出红黑树中所有检测点编号即可。

## C++代码

```cpp
#include <bits/stdc++.h>
using namespace std;
using gg = long long;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    gg ni, xi, yi, a, b;
    cin >> ni >> xi >> yi;
    set<array<gg, 2>> s;
    for (gg i = 1; i <= ni; ++i) {
        cin >> a >> b;
        gg d = (a - xi) * (a - xi) + (b - yi) * (b - yi);
        if (s.size() < 3 or (*s.rbegin())[0] > d) {
            if (s.size() >= 3) {
                s.erase(prev(s.end()));
            }
            s.insert({d, i});
        }
    }
    for (auto& i : s) {
        cout << i[1] << "\n";
    }
    return 0;
}
```
